stages:
  - checkout
  - build_frontend
  - build_backend
  - deploy

variables:
  FRONT_DIR: "frontend"
  BACK_DIR: "back"
  COMPOSE_FILE: "docker-compose.yml"
  DOCKER_HOST: tcp://docker:2375  # Ensures Docker client can communicate with Docker-in-Docker

# Checkout code
checkout_code:
  stage: checkout
  script:
    - echo "ğŸ“¥ Checking out the project..."
    - echo "Code is already checked out by GitLab Runner."

# Build Angular Frontend
build_angular_frontend:
  stage: build_frontend
  image: node:18  # Use Node.js image for Angular build
  script:
    - echo "ğŸ“¦ Installing dependencies and building Angular app..."
    - cd $FRONT_DIR
    - npm install --legacy-peer-deps
    - npm run build -- --configuration=production
  artifacts:
    paths:
      - frontend/dist/
    expire_in: 1 week
  cache:
    paths:
      - frontend/node_modules/

# Build Backend (Spring Boot app)
build_backend:
  stage: build_backend
  image: maven:3.9.6-eclipse-temurin-21  # Use Maven image for Spring Boot build
  script:
    - echo "ğŸ”§ Installing backend dependencies and building the Spring Boot app..."
    - cd $BACK_DIR
    - mvn clean package -DskipTests  # Build the Spring Boot app (adjust command if necessary)
  artifacts:
    paths:
      - back/target/
    expire_in: 1 week

# Deploy with Docker Compose
docker_compose_up:
  stage: deploy
  image: docker:20.10.16  # Docker image with Docker client
  services:
    - name: docker:20.10.16-dind  # Docker-in-Docker service
      command: ["--host=tcp://0.0.0.0:2375"]  # Make Docker daemon listen on TCP port 2375
  script:
    - echo "ğŸ³ Stopping existing containers (if any)..."
    - docker-compose -f $COMPOSE_FILE down || true
    - echo "ğŸ³ Building Docker images..."
    - docker-compose -f $COMPOSE_FILE build
    - echo "ğŸ³ Starting containers..."
    - docker-compose -f $COMPOSE_FILE up -d
  when: on_success
